# deepseekr1maker/rewards/format_reward.py
import re
from typing import List, Dict, Any, Optional, Union

def format_reward(completions, return_diagnostics=False, **kwargs):
    """
    Reward function to check if the completion follows the required format:
    <think>...</think> <answer>...</answer>.
    
    Args:
        completions: List of completions generated by the model
        return_diagnostics: Whether to return detailed diagnostic information
        **kwargs: Additional arguments including:
            - format_pattern: Custom regex pattern to check (optional)
            - required_tags: List of tags that must be present (optional)
            - case_sensitive: Whether tag matching should be case-sensitive (default: False)
            - strict_order: Whether tags must appear in exact order (default: True)
            - allow_extra_content: Whether content outside tags is allowed (default: False)
    
    Returns:
        If return_diagnostics=False:
            List of reward scores (1.0 for correct format, 0.0 for incorrect)
        If return_diagnostics=True:
            List of dictionaries containing reward scores and diagnostic information
    """
    # Extract configuration from kwargs
    custom_pattern = kwargs.get("format_pattern", None)
    required_tags = kwargs.get("required_tags", ["think", "answer"])
    case_sensitive = kwargs.get("case_sensitive", False)
    strict_order = kwargs.get("strict_order", True)
    allow_extra_content = kwargs.get("allow_extra_content", False)
    
    # Extract content from each completion
    completion_contents = [completion[0]["content"] for completion in completions]
    
    # Prepare results
    rewards = []
    diagnostics = []
    
    # Define regex flags
    flags = re.DOTALL | re.MULTILINE
    if not case_sensitive:
        flags |= re.IGNORECASE
    
    # Create the pattern based on configuration
    if custom_pattern:
        pattern = custom_pattern
    else:
        if strict_order and not allow_extra_content:
            # Strict format: <tag1>...</tag1><tag2>...</tag2>
            pattern_parts = []
            for tag in required_tags:
                pattern_parts.append(f"<{tag}>.*?</{tag}>")
            pattern = r"^\s*" + r"\s*".join(pattern_parts) + r"\s*$"
        elif strict_order and allow_extra_content:
            # Order matters but can have other content
            pattern_parts = []
            for tag in required_tags:
                pattern_parts.append(f"<{tag}>.*?</{tag}>")
            pattern = r".*" + r".*?".join(pattern_parts) + r".*"
        else:
            # Just check that all required tags are present somewhere
            pattern = r".*"  # Placeholder, we'll check tags individually
    
    # Check each completion
    for idx, content in enumerate(completion_contents):
        diagnostic_info = {
            "status": "unknown",
            "details": "",
            "missing_tags": [],
            "malformed_tags": []
        }
        
        # Handle empty content
        if not content or content.strip() == "":
            reward = 0.0
            diagnostic_info["status"] = "empty_content"
            diagnostic_info["details"] = "Completion is empty"
        
        # Use custom or strict pattern if defined
        elif custom_pattern or (strict_order and not allow_extra_content):
            match = re.match(pattern, content, flags)
            if match:
                reward = 1.0
                diagnostic_info["status"] = "correct_format"
                diagnostic_info["details"] = "Completion follows the required format"
            else:
                reward = 0.0
                diagnostic_info["status"] = "incorrect_format"
                diagnostic_info["details"] = "Completion does not follow the required format"
                
                # Detailed diagnostics
                if strict_order and not allow_extra_content:
                    if content.strip() and not re.match(r"^\s*<", content, flags):
                        diagnostic_info["details"] += ": Content before first tag"
                    
                    # Check for each tag
                    for tag in required_tags:
                        open_tag = f"<{tag}>"
                        close_tag = f"</{tag}>"
                        
                        if not case_sensitive:
                            pattern_open = re.compile(re.escape(open_tag), re.IGNORECASE)
                            pattern_close = re.compile(re.escape(close_tag), re.IGNORECASE)
                        else:
                            pattern_open = re.compile(re.escape(open_tag))
                            pattern_close = re.compile(re.escape(close_tag))
                        
                        if not pattern_open.search(content):
                            diagnostic_info["missing_tags"].append(f"<{tag}>")
                        if not pattern_close.search(content):
                            diagnostic_info["missing_tags"].append(f"</{tag}>")
                        elif pattern_open.search(content) and pattern_close.search(content):
                            # Check if they're properly nested
                            open_pos = pattern_open.search(content).start()
                            close_pos = pattern_close.search(content).start()
                            if close_pos < open_pos:
                                diagnostic_info["malformed_tags"].append(f"Closing tag </{tag}> appears before opening tag <{tag}>")
        
        # More flexible checking (all tags present but order may vary)
        else:
            all_tags_present = True
            missing_tags = []
            
            for tag in required_tags:
                open_tag = f"<{tag}>"
                close_tag = f"</{tag}>"
                
                if not case_sensitive:
                    pattern_open = re.compile(re.escape(open_tag), re.IGNORECASE)
                    pattern_close = re.compile(re.escape(close_tag), re.IGNORECASE)
                else:
                    pattern_open = re.compile(re.escape(open_tag))
                    pattern_close = re.compile(re.escape(close_tag))
                
                if not pattern_open.search(content):
                    all_tags_present = False
                    missing_tags.append(f"<{tag}>")
                if not pattern_close.search(content):
                    all_tags_present = False
                    missing_tags.append(f"</{tag}>")
            
            # Check order if required
            order_correct = True
            if strict_order and all_tags_present:
                # Check tag order
                expected_order = []
                for tag in required_tags:
                    expected_order.append(f"<{tag}>")
                    expected_order.append(f"</{tag}>")
                
                # Get actual positions of all tags
                tag_positions = []
                for tag in required_tags:
                    open_tag = f"<{tag}>"
                    close_tag = f"</{tag}>"
                    
                    if not case_sensitive:
                        pattern_open = re.compile(re.escape(open_tag), re.IGNORECASE)
                        pattern_close = re.compile(re.escape(close_tag), re.IGNORECASE)
                    else:
                        pattern_open = re.compile(re.escape(open_tag))
                        pattern_close = re.compile(re.escape(close_tag))
                    
                    match_open = pattern_open.search(content)
                    match_close = pattern_close.search(content)
                    
                    tag_positions.append((open_tag, match_open.start() if match_open else float('inf')))
                    tag_positions.append((close_tag, match_close.start() if match_close else float('inf')))
                
                # Sort by position
                tag_positions.sort(key=lambda x: x[1])
                actual_order = [tag for tag, pos in tag_positions if pos != float('inf')]
                
                # Check if opening tags appear before their closing tags
                for tag in required_tags:
                    open_tag = f"<{tag}>"
                    close_tag = f"</{tag}>"
                    
                    open_idx = actual_order.index(open_tag) if open_tag in actual_order else -1
                    close_idx = actual_order.index(close_tag) if close_tag in actual_order else -1
                    
                    if open_idx >= 0 and close_idx >= 0 and open_idx > close_idx:
                        order_correct = False
                        diagnostic_info["malformed_tags"].append(f"Closing tag </{tag}> appears before opening tag <{tag}>")
                
                # Check if tags are properly nested
                if strict_order and len(required_tags) > 1:
                    for i in range(len(required_tags) - 1):
                        tag1_open = f"<{required_tags[i]}>"
                        tag1_close = f"</{required_tags[i]}>"
                        tag2_open = f"<{required_tags[i+1]}>"
                        tag2_close = f"</{required_tags[i+1]}>"
                        
                        if (tag1_open in actual_order and tag1_close in actual_order and 
                            tag2_open in actual_order and tag2_close in actual_order):
                            
                            idx1_open = actual_order.index(tag1_open)
                            idx1_close = actual_order.index(tag1_close)
                            idx2_open = actual_order.index(tag2_open)
                            idx2_close = actual_order.index(tag2_close)
                            
                            # For sequential tags, check correct ordering:
                            # <tag1>...</tag1><tag2>...</tag2>
                            if not (idx1_open < idx1_close < idx2_open < idx2_close):
                                order_correct = False
                                diagnostic_info["malformed_tags"].append(
                                    f"Tags are not properly ordered. Expected: {tag1_open}...{tag1_close}{tag2_open}...{tag2_close}"
                                )
            
            # Determine final reward
            if all_tags_present and order_correct:
                reward = 1.0
                diagnostic_info["status"] = "correct_format"
                diagnostic_info["details"] = "Completion contains all required tags in correct order"
            else:
                reward = 0.0
                diagnostic_info["status"] = "incorrect_format"
                
                if missing_tags:
                    diagnostic_info["missing_tags"] = missing_tags
                    diagnostic_info["details"] = f"Missing tags: {', '.join(missing_tags)}"
                elif not order_correct:
                    diagnostic_info["details"] = "Tags are not in the correct order"
        
        # Store results
        diagnostic_info["reward"] = reward
        rewards.append(reward)
        diagnostics.append(diagnostic_info)
    
    if return_diagnostics:
        return diagnostics
    return rewards


def tag_extraction_reward(completions, tag_name="answer", return_content=False, **kwargs):
    """
    Extracts content from specific XML-like tags and optionally returns it.
    Useful for extracting model answers for further processing.
    
    Args:
        completions: List of completions generated by the model
        tag_name: Name of the tag to extract content from
        return_content: Whether to return the extracted content instead of rewards
        **kwargs: Additional arguments including:
            - case_sensitive: Whether tag matching should be case-sensitive (default: False)
    
    Returns:
        If return_content=False:
            List of reward scores (1.0 if tag was found, 0.0 otherwise)
        If return_content=True:
            List of extracted contents (or None if tag not found)
    """
    case_sensitive = kwargs.get("case_sensitive", False)
    
    # Extract content from each completion
    completion_contents = [completion[0]["content"] for completion in completions]
    
    # Prepare results
    rewards = []
    extracted_contents = []
    
    # Define regex flags
    flags = re.DOTALL | re.MULTILINE
    if not case_sensitive:
        flags |= re.IGNORECASE
    
    # Create the pattern for extraction
    pattern = f"<{tag_name}>(.*?)</{tag_name}>"
    
    # Check each completion
    for content in completion_contents:
        match = re.search(pattern, content, flags)
        if match:
            extracted = match.group(1).strip()
            rewards.append(1.0)
            extracted_contents.append(extracted)
        else:
            rewards.append(0.0)
            extracted_contents.append(None)
    
    if return_content:
        return extracted_contents
    return rewards