# deepseekr1maker/rewards/reasoning_reward.py
import re
#from typing import List, Dict, Any, Optional, Union
from collections import Counter

def reasoning_steps_reward(completions, return_diagnostics=False, **kwargs):
    """
    Reward function to encourage clear step-by-step reasoning.
    Searches for patterns like "Step 1:", numbered lists, bullet points,
    and transition words.
    
    Args:
        completions: List of completions generated by the model
        return_diagnostics: Whether to return detailed diagnostic information
        **kwargs: Additional arguments including:
            - min_steps: Minimum number of steps required for full reward (default: 3)
            - max_steps: Maximum number of steps considered (default: 10)
            - step_patterns: Custom patterns to look for as reasoning steps
            - require_conclusion: Whether to require a conclusion (default: True)
            - language: Preferred language ('en', 'fr', or 'both', default: 'both')
            - check_reasoning_quality: Whether to assess reasoning quality (default: False)
    
    Returns:
        If return_diagnostics=False:
            List of reward scores (proportion of reasoning quality, max at 1.0)
        If return_diagnostics=True:
            List of dictionaries containing reward scores and diagnostic information
    """
    # Get configuration from kwargs
    min_steps = kwargs.get("min_steps", 3)  # Default to 3 as in the original function
    max_steps = kwargs.get("max_steps", None)  # No maximum by default
    require_conclusion = kwargs.get("require_conclusion", True)
    language = kwargs.get("language", "both")
    check_reasoning_quality = kwargs.get("check_reasoning_quality", False)
    custom_patterns = kwargs.get("step_patterns", None)
    
    # Extract content from each completion
    completion_contents = [completion[0]["content"] for completion in completions]
    
    # Define the patterns for step indicators based on language preference
    english_patterns = [
        r"(?:^|\\n)Step\s+(\d+)[:.)]",          # Step 1: or Step 1. or Step 1)
        r"(?:^|\\n)(\d+)[\.\)](?!\d)",          # 1. or 1) but not 1.5
        r"(?:^|\\n)[*\-•](?!\*)",               # Bullet points (* - •)
        r"(?:^|\\n)(?:First|1st)[,:]",          # First, or First:
        r"(?:^|\\n)(?:Second|2nd)[,:]",         # Second, or Second:
        r"(?:^|\\n)(?:Third|3rd)[,:]",          # Third, or Third:
        r"(?:^|\\n)(?:Fourth|4th)[,:]",         # Fourth, or Fourth:
        r"(?:^|\\n)(?:Fifth|5th)[,:]",          # Fifth, or Fifth:
        r"(?:^|\\n)(?:Next|Then|Subsequently|Afterwards)[,:]",  # Transition words
        r"(?:^|\\n)(?:Finally|Lastly|In\s+conclusion)[,:]"      # Conclusion markers
    ]
    
    french_patterns = [
        r"(?:^|\\n)Étape\s+(\d+)[:.)]",         # Étape 1: or Étape 1. or Étape 1)
        r"(?:^|\\n)(\d+)[\.\)](?!\d)",          # 1. or 1) but not 1.5
        r"(?:^|\\n)[*\-•](?!\*)",               # Bullet points (* - •)
        r"(?:^|\\n)(?:Premièrement|1er)[,:]",   # Premièrement, or Premièrement:
        r"(?:^|\\n)(?:Deuxièmement|2ème)[,:]",  # Deuxièmement, or Deuxièmement:
        r"(?:^|\\n)(?:Troisièmement|3ème)[,:]", # Troisièmement, or Troisièmement:
        r"(?:^|\\n)(?:Quatrièmement|4ème)[,:]", # Quatrièmement, or Quatrièmement:
        r"(?:^|\\n)(?:Cinquièmement|5ème)[,:]", # Cinquièmement, or Cinquièmement:
        r"(?:^|\\n)(?:Ensuite|Puis|Par\s+la\s+suite)[,:]",     # Transition words
        r"(?:^|\\n)(?:Enfin|Finalement|En\s+conclusion)[,:]"    # Conclusion markers
    ]
    
    # Determine which patterns to use based on language preference
    if language == "en":
        patterns = english_patterns
    elif language == "fr":
        patterns = french_patterns
    else:  # "both" or any other value
        patterns = english_patterns + french_patterns
    
    # Add custom patterns if provided
    if custom_patterns:
        patterns.extend(custom_patterns)
    
    # Prepare results
    rewards = []
    diagnostics = []
    
    # Process each completion
    for content in completion_contents:
        # Initialize diagnostic information
        diagnostic_info = {
            "steps_found": 0,
            "step_types": {},
            "step_sequence": [],
            "has_conclusion": False,
            "reasoning_quality": "unknown",
            "issues": []
        }
        
        # Count pattern matches
        total_steps = 0
        step_types = Counter()
        step_sequence = []
        
        for pattern in patterns:
            matches = re.findall(pattern, content, re.MULTILINE | re.IGNORECASE)
            count = len(matches)
            
            if count > 0:
                step_types[pattern] = count
                total_steps += count
                
                # Extract the step numbers if present (for numbered steps)
                if '(\\d+)' in pattern:
                    # Try to extract step numbers to check sequence
                    for match in re.finditer(pattern, content, re.MULTILINE | re.IGNORECASE):
                        if match.groups():
                            try:
                                step_num = int(match.group(1))
                                step_sequence.append(step_num)
                            except (ValueError, IndexError):
                                pass
        
        # Check for a conclusion
        has_conclusion = False
        conclusion_patterns = [
            r"(?:in\s+conclusion|to\s+conclude|therefore|thus|hence|consequently)",
            r"(?:en\s+conclusion|pour\s+conclure|donc|ainsi|par\s+conséquent)"
        ]
        
        for pattern in conclusion_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                has_conclusion = True
                break
        
        # Calculate base reward based on number of steps
        if total_steps == 0:
            base_reward = 0.0
            diagnostic_info["issues"].append("No reasoning steps detected")
        else:
            # Normalize to between 0 and 1 based on min_steps
            base_reward = min(1.0, total_steps / min_steps)
            
            # Cap at max_steps if specified
            if max_steps is not None and total_steps > max_steps:
                base_reward = 1.0
        
        # Adjust reward based on conclusion if required
        if require_conclusion and not has_conclusion and base_reward > 0:
            base_reward *= 0.8  # Penalize by 20% if conclusion is missing
            diagnostic_info["issues"].append("Missing conclusion")
        
        # Check reasoning quality if requested
        reasoning_quality = 1.0  # Default quality multiplier
        
        if check_reasoning_quality and total_steps > 0:
            # Check for sequential reasoning (for numbered steps)
            if step_sequence:
                # Sort and check for gaps or duplicates
                step_sequence.sort()
                
                # Check if steps are sequential (1,2,3,...)
                expected_sequence = list(range(1, len(step_sequence) + 1))
                if step_sequence != expected_sequence:
                    diagnostic_info["issues"].append(f"Non-sequential step numbering: {step_sequence}")
                    reasoning_quality *= 0.9  # 10% penalty for non-sequential numbering
            
            # Check for balanced step distribution (no single giant step)
            if len(step_types) == 1 and total_steps > 3:
                diagnostic_info["issues"].append("Unbalanced reasoning structure - relies on a single step type")
                reasoning_quality *= 0.9  # 10% penalty for unbalanced structure
            
            # Check step density (steps relative to content length)
            content_length = len(content)
            if content_length > 0:
                step_density = total_steps / (content_length / 500)  # Normalize to ~500 chars per step
                
                if step_density < 0.5:  # Too sparse
                    diagnostic_info["issues"].append("Steps are too sparse relative to content length")
                    reasoning_quality *= 0.9
                elif step_density > 3:  # Too dense
                    diagnostic_info["issues"].append("Too many steps with minimal content between them")
                    reasoning_quality *= 0.9
            
            # Update reasoning quality assessment
            if reasoning_quality > 0.95:
                diagnostic_info["reasoning_quality"] = "excellent"
            elif reasoning_quality > 0.85:
                diagnostic_info["reasoning_quality"] = "good"
            elif reasoning_quality > 0.75:
                diagnostic_info["reasoning_quality"] = "fair"
            else:
                diagnostic_info["reasoning_quality"] = "poor"
        
        # Calculate final reward
        final_reward = base_reward * reasoning_quality
        
        # Update diagnostic information
        diagnostic_info["steps_found"] = total_steps
        diagnostic_info["step_types"] = {str(k): v for k, v in step_types.items()}  # Convert regex to string
        diagnostic_info["step_sequence"] = step_sequence
        diagnostic_info["has_conclusion"] = has_conclusion
        diagnostic_info["reward"] = final_reward
        
        # Store results
        rewards.append(final_reward)
        diagnostics.append(diagnostic_info)
    
    if return_diagnostics:
        return diagnostics
    return rewards


def reasoning_coherence_reward(completions, **kwargs):
    """
    Reward function to assess the logical coherence of reasoning.
    Looks for logical connectors and the flow of reasoning.
    
    Args:
        completions: List of completions generated by the model
        **kwargs: Additional arguments including:
            - connectors: List of logical connectors to look for
            - min_connectors: Minimum number of connectors for full reward (default: 5)
            - check_contradictions: Whether to check for contradictions (default: False)
            - language: Preferred language ('en', 'fr', or 'both', default: 'both')
    
    Returns:
        List of reward scores (0.0 to 1.0 based on logical coherence)
    """
    # Get configuration from kwargs
    min_connectors = kwargs.get("min_connectors", 5)
    check_contradictions = kwargs.get("check_contradictions", False)
    language = kwargs.get("language", "both")
    custom_connectors = kwargs.get("connectors", None)
    
    # Extract content from each completion
    completion_contents = [completion[0]["content"] for completion in completions]
    
    # Define logical connectors based on language
    english_connectors = [
        r"\b(?:because|since|as)\b",           # Causation
        r"\b(?:therefore|thus|hence)\b",        # Conclusion
        r"\b(?:however|but|yet)\b",             # Contrast
        r"\b(?:if|when|unless)\b",              # Condition
        r"\b(?:and|moreover|additionally)\b",   # Addition
        r"\b(?:or|alternatively)\b",            # Alternative
        r"\b(?:for example|such as)\b",         # Example
        r"\b(?:in other words|that is)\b",      # Clarification
        r"\b(?:in fact|indeed|actually)\b",     # Emphasis
        r"\b(?:similarly|likewise)\b"           # Comparison
    ]
    
    french_connectors = [
        r"\b(?:parce que|puisque|car)\b",       # Causation
        r"\b(?:donc|ainsi|par conséquent)\b",   # Conclusion
        r"\b(?:cependant|mais|pourtant)\b",     # Contrast
        r"\b(?:si|quand|à moins que)\b",        # Condition
        r"\b(?:et|de plus|en outre)\b",         # Addition
        r"\b(?:ou|autrement)\b",                # Alternative
        r"\b(?:par exemple|tel que)\b",         # Example
        r"\b(?:en d'autres termes|c'est-à-dire)\b", # Clarification
        r"\b(?:en fait|effectivement)\b",       # Emphasis
        r"\b(?:de même|pareillement)\b"         # Comparison
    ]
    
    # Determine which connectors to use based on language preference
    if language == "en":
        connectors = english_connectors
    elif language == "fr":
        connectors = french_connectors
    else:  # "both" or any other value
        connectors = english_connectors + french_connectors
    
    # Add custom connectors if provided
    if custom_connectors:
        connectors.extend(custom_connectors)
    
    # Define contradictory phrases if checking for contradictions
    contradictions = []
    if check_contradictions:
        english_contradictions = [
            r"(?:on one hand.*on the other hand)",
            r"\b(?:I was wrong|incorrect earlier|I made a mistake)\b",
            r"(?:Actually, let me reconsider)",
            r"(?:This is incorrect, instead)"
        ]
        
        french_contradictions = [
            r"(?:d'une part.*d'autre part)",
            r"\b(?:j'avais tort|erreur précédente|j'ai fait une erreur)\b",
            r"(?:En fait, reconsidérons)",
            r"(?:C'est incorrect, plutôt)"
        ]
        
        if language == "en":
            contradictions = english_contradictions
        elif language == "fr":
            contradictions = french_contradictions
        else:
            contradictions = english_contradictions + french_contradictions
    
    # Process each completion
    rewards = []
    
    for content in completion_contents:
        # Count logical connectors
        connector_count = 0
        connector_types = set()
        
        for pattern in connectors:
            matches = re.findall(pattern, content, re.IGNORECASE)
            connector_count += len(matches)
            if matches:
                connector_types.add(pattern)
        
        # Base reward on connector count and variety
        connector_variety = len(connector_types)
        
        # Reward based on connector count (capped at min_connectors)
        count_reward = min(1.0, connector_count / min_connectors)
        
        # Bonus for variety of connectors
        variety_bonus = min(0.2, connector_variety / len(connectors) * 0.2)
        
        # Combined base reward
        base_reward = count_reward + variety_bonus
        
        # Check for contradictions if enabled
        contradiction_penalty = 0
        if check_contradictions:
            for pattern in contradictions:
                if re.search(pattern, content, re.IGNORECASE | re.DOTALL):
                    contradiction_penalty += 0.2  # 20% penalty per type of contradiction
            
            contradiction_penalty = min(0.6, contradiction_penalty)  # Cap at 60% penalty
        
        # Calculate final reward
        final_reward = max(0, min(1.0, base_reward * (1 - contradiction_penalty)))
        rewards.append(final_reward)
    
    return rewards